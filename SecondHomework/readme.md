
### 模仿老师的思路，自己对所有权、不可变引用、可变引用这三者的规则或特性做一个集中的总结，写一个笔记列表。
1. 所有权：
在解释所有权概念之前，必须要说下浅拷贝和深拷贝，同时也需要讲下数据的存储，是栈存储还是堆存储。

1.1 数据存储
- 栈存储：数据是固定长度数据，不会动态变化的数据都是保存在栈上面的，比方说一些值类型数据，布尔类型的数据；
- 堆存储：数据是动态变化的，不能确定数据的长度，数据可能是动态增长或者减少的，这些都是存储在堆上面的，动态数组等数据；

1.2 浅拷贝和深拷贝  
- 浅拷贝：可以简单理解只拷贝第一层，剩下都是指针的复用；
- 深拷贝：对复杂的数据类型进行多层次的值拷贝，每一次都是值的拷贝，而非指针的复用；
- 比方说u32的复制就是深拷贝，是值的复制，这时候两个值都拥有所有权，但是如果是多余字符串来说，字符串是不固定的长度，所以是动态的，存在堆数据上，堆数据赋值是浅拷贝是复制指针，其它语言是两个指针指向同一个堆地址，但是rust的堆复制以后只能最新的这个赋值，其它赋值的指针都会标记无效，当前只确定一个变量拥有该值，来确保内存安全操作


1.3 常见的语言面临的问题是什么？所有权解决了什么问题？  
- 常见的语言对于数据的存储会面临泄漏内存安全的问题，由于没有人为管理好内存，有可能导致管理的内存发生泄漏，导致生产安全问题;  
- Rust 的所有权有效的管理好了内存，避免了内存泄漏问题，提高了内存安全，Rust 所有权规定每一个变量有且仅只能拥有一个资源管理，杜绝了像其它语言多个变量指向一个指针问题，解决了内存泄漏问题。

1.4 怎么判断是复制所有权还是移动move所有权？
- 值类型的都是复制：整数，浮点，布尔，字符char， 前面几个类型构成的元组；
- 移动所有权类型：固定数组，动态数组，hashMap， 结构体 这些类型都是移动所有权；

1.5 为什么需要不可变引用和可变引用？
- 因为在设置内存管理的时候，需要考虑性能的问题，如果是一个特别大的值类型数据，单纯复制值类型的数据太消耗性能，如果是move移动所有权，那太过于繁琐，所以就引出在不改变所有权的情况下，把值借用给其它变量使用。

1.6 什么是不可变引用（借用），什么是可变引用？
- 不可变引用：在不改变所有权的情况下，把值借给其它变量使用，不能修改原值；
- 可变引用： 在不改变所有权的情况下，把值借给其它变量使用，并且有权利修改原值；